<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【java.awt.*】 - README]]></title>
    <url>%2Fjava.awt%2FREADME%2F</url>
    <content type="text"><![CDATA[123456789101112131415java.awt（用户界面和绘图相关） ├── color （提供颜色空间的类） ├── datatransfer（提供用于在应用程序之间和之内传输数据的接口和类） ├── dnd（拖放是在许多图形用户界面系统中发现的直接操纵手势，其提供了在GUI中与表示元素逻辑相关联的两个实体之间传递信息的机制） │ └── peer（1） ├── event（提供用于处理AWT组件触发的不同类型事件的接口和类） ├── font（提供与字体相关的类和界面） ├── geom（提供Java 2D类，用于定义和执行与二维几何体相关的对象的操作） ├── im（为输入方法框架提供类和接口） │ └── spi（提供可用于开发可与任何Java运行时环境一起使用的输入方法的接口） ├── image（提供用于创建和修改图像的类） │ └── renderable（提供用于生成与渲染无关的图像的类和接口） ├── peer（各组件接口定义） ├── print（为常规打印API提供类和接口） └─ *.java（用户界面和绘图相关基础类） 包简介包含用于创建用户界面和绘制图形和图像的所有类。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384java.awt ├── AWTError.java ├── AWTEvent.java ├── AWTEventMulticaster.java ├── AWTException.java ├── AWTKeyStroke.java ├── AWTPermission.java ├── ActiveEvent.java ├── Adjustable.java ├── AlphaComposite.java ├── AttributeValue.java ├── BasicStroke.java ├── BorderLayout.java ├── BufferCapabilities.java ├── Button.java ├── Canvas.java ├── CardLayout.java ├── Checkbox.java ├── CheckboxGroup.java ├── CheckboxMenuItem.java ├── Choice.java ├── Color.java ├── ColorPaintContext.java ├── Component.java ├── ComponentOrientation.java ├── Composite.java ├── CompositeContext.java ├── Conditional.java ├── Container.java ├── ContainerOrderFocusTraversalPolicy.java ├── Cursor.java ├── DefaultFocusTraversalPolicy.java ├── DefaultKeyboardFocusManager.java ├── Desktop.java ├── Dialog.java ├── Dimension.java ├── DisplayMode.java ├── Event.java ├── EventDispatchThread.java ├── EventFilter.java ├── EventQueue.java ├── FileDialog.java ├── FlowLayout.java ├── FocusTraversalPolicy.java ├── Font.java ├── FontFormatException.java ├── FontMetrics.java ├── Frame.java ├── GradientPaint.java ├── GradientPaintContext.java ├── Graphics.java ├── Graphics2D.java ├── GraphicsCallback.java ├── GraphicsConfigTemplate.java ├── GraphicsConfiguration.java ├── GraphicsDevice.java ├── GraphicsEnvironment.java ├── GridBagConstraints.java ├── GridBagLayout.java ├── GridBagLayoutInfo.java ├── GridLayout.java ├── HeadlessException.java ├── IllegalComponentStateException.java ├── Image.java ├── ImageCapabilities.java ├── Insets.java ├── ItemSelectable.java ├── JobAttributes.java ├── KeyEventDispatcher.java ├── KeyEventPostProcessor.java ├── KeyboardFocusManager.java ├── Label.java ├── LayoutManager.java ├── LayoutManager2.java ├── LinearGradientPaint.java ├── LinearGradientPaintContext.java ├── List.java ├── MediaTracker.java ├── Menu.java ├── MenuBar.java ├── MenuComponent.java ├── MenuContainer.java ├── MenuItem.java ├── MenuShortcut.java ├── ModalEventFilter.java ├── MouseInfo.java ├── MultipleGradientPaint.java ├── MultipleGradientPaintContext.java ├── PageAttributes.java ├── Paint.java ├── PaintContext.java ├── Panel.java ├── Point.java ├── PointerInfo.java ├── Polygon.java ├── PopupMenu.java ├── PrintGraphics.java ├── PrintJob.java ├── RadialGradientPaint.java ├── RadialGradientPaintContext.java ├── Rectangle.java ├── RenderingHints.java ├── Robot.java ├── ScrollPane.java ├── ScrollPaneAdjustable.java ├── Scrollbar.java ├── SecondaryLoop.java ├── SentEvent.java ├── SequencedEvent.java ├── Shape.java ├── SplashScreen.java ├── Stroke.java ├── SystemColor.java ├── SystemTray.java ├── TextArea.java ├── TextComponent.java ├── TextField.java ├── TexturePaint.java ├── TexturePaintContext.java ├── Toolkit.java ├── Transparency.java ├── TrayIcon.java ├── WaitDispatchSupport.java ├── Window.java ├── color │ ├── CMMException.java │ ├── ColorSpace.java │ ├── ICC_ColorSpace.java │ ├── ICC_Profile.java │ ├── ICC_ProfileGray.java │ ├── ICC_ProfileRGB.java │ └── ProfileDataException.java ├── datatransfer │ ├── Clipboard.java │ ├── ClipboardOwner.java │ ├── DataFlavor.java │ ├── FlavorEvent.java │ ├── FlavorListener.java │ ├── FlavorMap.java │ ├── FlavorTable.java │ ├── MimeType.java │ ├── MimeTypeParameterList.java │ ├── MimeTypeParseException.java │ ├── StringSelection.java │ ├── SystemFlavorMap.java │ ├── Transferable.java │ └── UnsupportedFlavorException.java ├── dnd │ ├── Autoscroll.java │ ├── DnDConstants.java │ ├── DnDEventMulticaster.java │ ├── DragGestureEvent.java │ ├── DragGestureListener.java │ ├── DragGestureRecognizer.java │ ├── DragSource.java │ ├── DragSourceAdapter.java │ ├── DragSourceContext.java │ ├── DragSourceDragEvent.java │ ├── DragSourceDropEvent.java │ ├── DragSourceEvent.java │ ├── DragSourceListener.java │ ├── DragSourceMotionListener.java │ ├── DropTarget.java │ ├── DropTargetAdapter.java │ ├── DropTargetContext.java │ ├── DropTargetDragEvent.java │ ├── DropTargetDropEvent.java │ ├── DropTargetEvent.java │ ├── DropTargetListener.java │ ├── InvalidDnDOperationException.java │ ├── MouseDragGestureRecognizer.java │ ├── SerializationTester.java │ └── peer │ ├── DragSourceContextPeer.java │ ├── DropTargetContextPeer.java │ └── DropTargetPeer.java ├── event │ ├── AWTEventListener.java │ ├── AWTEventListenerProxy.java │ ├── ActionEvent.java │ ├── ActionListener.java │ ├── AdjustmentEvent.java │ ├── AdjustmentListener.java │ ├── ComponentAdapter.java │ ├── ComponentEvent.java │ ├── ComponentListener.java │ ├── ContainerAdapter.java │ ├── ContainerEvent.java │ ├── ContainerListener.java │ ├── FocusAdapter.java │ ├── FocusEvent.java │ ├── FocusListener.java │ ├── HierarchyBoundsAdapter.java │ ├── HierarchyBoundsListener.java │ ├── HierarchyEvent.java │ ├── HierarchyListener.java │ ├── InputEvent.java │ ├── InputMethodEvent.java │ ├── InputMethodListener.java │ ├── InvocationEvent.java │ ├── ItemEvent.java │ ├── ItemListener.java │ ├── KeyAdapter.java │ ├── KeyEvent.java │ ├── KeyListener.java │ ├── MouseAdapter.java │ ├── MouseEvent.java │ ├── MouseListener.java │ ├── MouseMotionAdapter.java │ ├── MouseMotionListener.java │ ├── MouseWheelEvent.java │ ├── MouseWheelListener.java │ ├── NativeLibLoader.java │ ├── PaintEvent.java │ ├── TextEvent.java │ ├── TextListener.java │ ├── WindowAdapter.java │ ├── WindowEvent.java │ ├── WindowFocusListener.java │ ├── WindowListener.java │ └── WindowStateListener.java ├── font │ ├── CharArrayIterator.java │ ├── FontRenderContext.java │ ├── GlyphJustificationInfo.java │ ├── GlyphMetrics.java │ ├── GlyphVector.java │ ├── GraphicAttribute.java │ ├── ImageGraphicAttribute.java │ ├── LayoutPath.java │ ├── LineBreakMeasurer.java │ ├── LineMetrics.java │ ├── MultipleMaster.java │ ├── NumericShaper.java │ ├── OpenType.java │ ├── ShapeGraphicAttribute.java │ ├── StyledParagraph.java │ ├── TextAttribute.java │ ├── TextHitInfo.java │ ├── TextJustifier.java │ ├── TextLayout.java │ ├── TextLine.java │ ├── TextMeasurer.java │ └── TransformAttribute.java ├── geom │ ├── AffineTransform.java │ ├── Arc2D.java │ ├── ArcIterator.java │ ├── Area.java │ ├── CubicCurve2D.java │ ├── CubicIterator.java │ ├── Dimension2D.java │ ├── Ellipse2D.java │ ├── EllipseIterator.java │ ├── FlatteningPathIterator.java │ ├── GeneralPath.java │ ├── IllegalPathStateException.java │ ├── Line2D.java │ ├── LineIterator.java │ ├── NoninvertibleTransformException.java │ ├── Path2D.java │ ├── PathIterator.java │ ├── Point2D.java │ ├── QuadCurve2D.java │ ├── QuadIterator.java │ ├── RectIterator.java │ ├── Rectangle2D.java │ ├── RectangularShape.java │ ├── RoundRectIterator.java │ └── RoundRectangle2D.java ├── im │ ├── InputContext.java │ ├── InputMethodHighlight.java │ ├── InputMethodRequests.java │ ├── InputSubset.java │ └── spi │ ├── InputMethod.java │ ├── InputMethodContext.java │ └── InputMethodDescriptor.java ├── image │ ├── AffineTransformOp.java │ ├── AreaAveragingScaleFilter.java │ ├── BandCombineOp.java │ ├── BandedSampleModel.java │ ├── BufferStrategy.java │ ├── BufferedImage.java │ ├── BufferedImageFilter.java │ ├── BufferedImageOp.java │ ├── ByteLookupTable.java │ ├── ColorConvertOp.java │ ├── ColorModel.java │ ├── ComponentColorModel.java │ ├── ComponentSampleModel.java │ ├── ConvolveOp.java │ ├── CropImageFilter.java │ ├── DataBuffer.java │ ├── DataBufferByte.java │ ├── DataBufferDouble.java │ ├── DataBufferFloat.java │ ├── DataBufferInt.java │ ├── DataBufferShort.java │ ├── DataBufferUShort.java │ ├── DirectColorModel.java │ ├── FilteredImageSource.java │ ├── ImageConsumer.java │ ├── ImageFilter.java │ ├── ImageObserver.java │ ├── ImageProducer.java │ ├── ImagingOpException.java │ ├── IndexColorModel.java │ ├── Kernel.java │ ├── LookupOp.java │ ├── LookupTable.java │ ├── MemoryImageSource.java │ ├── MultiPixelPackedSampleModel.java │ ├── PackedColorModel.java │ ├── PixelGrabber.java │ ├── PixelInterleavedSampleModel.java │ ├── RGBImageFilter.java │ ├── Raster.java │ ├── RasterFormatException.java │ ├── RasterOp.java │ ├── RenderedImage.java │ ├── ReplicateScaleFilter.java │ ├── RescaleOp.java │ ├── SampleModel.java │ ├── ShortLookupTable.java │ ├── SinglePixelPackedSampleModel.java │ ├── TileObserver.java │ ├── VolatileImage.java │ ├── WritableRaster.java │ ├── WritableRenderedImage.java │ └── renderable │ ├── ContextualRenderedImageFactory.java │ ├── ParameterBlock.java │ ├── RenderContext.java │ ├── RenderableImage.java │ ├── RenderableImageOp.java │ ├── RenderableImageProducer.java │ └── RenderedImageFactory.java ├── peer │ ├── ButtonPeer.java │ ├── CanvasPeer.java │ ├── CheckboxMenuItemPeer.java │ ├── CheckboxPeer.java │ ├── ChoicePeer.java │ ├── ComponentPeer.java │ ├── ContainerPeer.java │ ├── DesktopPeer.java │ ├── DialogPeer.java │ ├── FileDialogPeer.java │ ├── FontPeer.java │ ├── FramePeer.java │ ├── KeyboardFocusManagerPeer.java │ ├── LabelPeer.java │ ├── LightweightPeer.java │ ├── ListPeer.java │ ├── MenuBarPeer.java │ ├── MenuComponentPeer.java │ ├── MenuItemPeer.java │ ├── MenuPeer.java │ ├── MouseInfoPeer.java │ ├── PanelPeer.java │ ├── PopupMenuPeer.java │ ├── RobotPeer.java │ ├── ScrollPanePeer.java │ ├── ScrollbarPeer.java │ ├── SystemTrayPeer.java │ ├── TextAreaPeer.java │ ├── TextComponentPeer.java │ ├── TextFieldPeer.java │ ├── TrayIconPeer.java │ └── WindowPeer.java └── print ├── Book.java ├── PageFormat.java ├── Pageable.java ├── Paper.java ├── Printable.java ├── PrinterAbortException.java ├── PrinterException.java ├── PrinterGraphics.java ├── PrinterIOException.java └── PrinterJob.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.applet.*】 - README]]></title>
    <url>%2Fjava.applet%2FREADME%2F</url>
    <content type="text"><![CDATA[12java.applet（提供创建applet所需的类以及applet用于与其applet上下文通信的类） └─ *.java（applet相关基础类） 包简介包含与开发bean相关的类 - 基于 JavaBeans™ 体系结构的组件。 详细目录12345java.applet ├── Applet.java ├── AppletContext.java ├── AppletStub.java └── AudioClip.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.time.*】 - README]]></title>
    <url>%2Fjava.time%2FREADME%2F</url>
    <content type="text"><![CDATA[123456java.time（日期，时间，瞬间和持续时间的主要API） ├── chrono（除默认ISO之外的日历系统的通用API） ├── format（提供用于打印和分析日期和时间的类） ├── temporal（使用字段和单位以及日期时间调整器访问日期和时间） ├── zone（支持时区及其规则） └─ *.java（日期时间相关基础类） 包简介包含与开发bean相关的类 - 基于 JavaBeans™ 体系结构的组件。 详细目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192java.time ├── Clock.java ├── DateTimeException.java ├── DayOfWeek.java ├── Duration.java ├── Instant.java ├── LocalDate.java ├── LocalDateTime.java ├── LocalTime.java ├── Month.java ├── MonthDay.java ├── OffsetDateTime.java ├── OffsetTime.java ├── Period.java ├── Ser.java ├── Year.java ├── YearMonth.java ├── ZoneId.java ├── ZoneOffset.java ├── ZoneRegion.java ├── ZonedDateTime.java ├── chrono │ ├── AbstractChronology.java │ ├── ChronoLocalDate.java │ ├── ChronoLocalDateImpl.java │ ├── ChronoLocalDateTime.java │ ├── ChronoLocalDateTimeImpl.java │ ├── ChronoPeriod.java │ ├── ChronoPeriodImpl.java │ ├── ChronoZonedDateTime.java │ ├── ChronoZonedDateTimeImpl.java │ ├── Chronology.java │ ├── Era.java │ ├── HijrahChronology.java │ ├── HijrahDate.java │ ├── HijrahEra.java │ ├── IsoChronology.java │ ├── IsoEra.java │ ├── JapaneseChronology.java │ ├── JapaneseDate.java │ ├── JapaneseEra.java │ ├── MinguoChronology.java │ ├── MinguoDate.java │ ├── MinguoEra.java │ ├── Ser.java │ ├── ThaiBuddhistChronology.java │ ├── ThaiBuddhistDate.java │ ├── ThaiBuddhistEra.java │ └── package-info.java ├── format │ ├── DateTimeFormatter.java │ ├── DateTimeFormatterBuilder.java │ ├── DateTimeParseContext.java │ ├── DateTimeParseException.java │ ├── DateTimePrintContext.java │ ├── DateTimeTextProvider.java │ ├── DecimalStyle.java │ ├── FormatStyle.java │ ├── Parsed.java │ ├── ResolverStyle.java │ ├── SignStyle.java │ ├── TextStyle.java │ ├── ZoneName.java │ └── package-info.java ├── package-info.java ├── temporal │ ├── ChronoField.java │ ├── ChronoUnit.java │ ├── IsoFields.java │ ├── JulianFields.java │ ├── Temporal.java │ ├── TemporalAccessor.java │ ├── TemporalAdjuster.java │ ├── TemporalAdjusters.java │ ├── TemporalAmount.java │ ├── TemporalField.java │ ├── TemporalQueries.java │ ├── TemporalQuery.java │ ├── TemporalUnit.java │ ├── UnsupportedTemporalTypeException.java │ ├── ValueRange.java │ ├── WeekFields.java │ └── package-info.java └── zone ├── Ser.java ├── TzdbZoneRulesProvider.java ├── ZoneOffsetTransition.java ├── ZoneOffsetTransitionRule.java ├── ZoneRules.java ├── ZoneRulesException.java ├── ZoneRulesProvider.java └── package-info.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.text.*】 - README]]></title>
    <url>%2Fjava.text%2FREADME%2F</url>
    <content type="text"><![CDATA[123java.text（文本处理相关） ├── spi（文本处理相关服务类） └─ *.java（文本处理相关基础类） 包简介提供以独立于自然语言的方式处理文本，日期，数字和消息的类和接口。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142java.text ├── Annotation.java ├── AttributedCharacterIterator.java ├── AttributedString.java ├── Bidi.java ├── BreakIterator.java ├── CalendarBuilder.java ├── CharacterIterator.java ├── CharacterIteratorFieldDelegate.java ├── ChoiceFormat.java ├── CollationElementIterator.java ├── CollationKey.java ├── Collator.java ├── DateFormat.java ├── DateFormatSymbols.java ├── DecimalFormat.java ├── DecimalFormatSymbols.java ├── DigitList.java ├── DontCareFieldPosition.java ├── EntryPair.java ├── FieldPosition.java ├── Format.java ├── MergeCollation.java ├── MessageFormat.java ├── Normalizer.java ├── NumberFormat.java ├── ParseException.java ├── ParsePosition.java ├── PatternEntry.java ├── RBCollationTables.java ├── RBTableBuilder.java ├── RuleBasedCollationKey.java ├── RuleBasedCollator.java ├── SimpleDateFormat.java ├── StringCharacterIterator.java └── spi ├── BreakIteratorProvider.java ├── CollatorProvider.java ├── DateFormatProvider.java ├── DateFormatSymbolsProvider.java ├── DecimalFormatSymbolsProvider.java └── NumberFormatProvider.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.sql.*】 - README]]></title>
    <url>%2Fjava.sql%2FREADME%2F</url>
    <content type="text"><![CDATA[12java.sql（访问和处理存储在数据源的API-通常是关系数据库） └─ *.java（数据源操作相关基础类） 包简介提供用于使用 Java™ 编程语言访问和处理存储在数据源（通常是关系数据库）中的数据的 API。 详细目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253java.sql ├── Array.java ├── BatchUpdateException.java ├── Blob.java ├── CallableStatement.java ├── ClientInfoStatus.java ├── Clob.java ├── Connection.java ├── DataTruncation.java ├── DatabaseMetaData.java ├── Date.java ├── Driver.java ├── DriverAction.java ├── DriverManager.java ├── DriverPropertyInfo.java ├── JDBCType.java ├── NClob.java ├── ParameterMetaData.java ├── PreparedStatement.java ├── PseudoColumnUsage.java ├── Ref.java ├── ResultSet.java ├── ResultSetMetaData.java ├── RowId.java ├── RowIdLifetime.java ├── SQLClientInfoException.java ├── SQLData.java ├── SQLDataException.java ├── SQLException.java ├── SQLFeatureNotSupportedException.java ├── SQLInput.java ├── SQLIntegrityConstraintViolationException.java ├── SQLInvalidAuthorizationSpecException.java ├── SQLNonTransientConnectionException.java ├── SQLNonTransientException.java ├── SQLOutput.java ├── SQLPermission.java ├── SQLRecoverableException.java ├── SQLSyntaxErrorException.java ├── SQLTimeoutException.java ├── SQLTransactionRollbackException.java ├── SQLTransientConnectionException.java ├── SQLTransientException.java ├── SQLType.java ├── SQLWarning.java ├── SQLXML.java ├── Savepoint.java ├── Statement.java ├── Struct.java ├── Time.java ├── Timestamp.java ├── Types.java └── Wrapper.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.beans.*】 - README]]></title>
    <url>%2Fjava.beans%2FREADME%2F</url>
    <content type="text"><![CDATA[123java.beans（bean相关的类） ├── beancontext（提供与bean上下文相关的类和接口） └─ *.java（bean相关的类） 包简介包含与开发bean相关的类 - 基于 JavaBeans™ 体系结构的组件。 详细目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465java.beans ├── AppletInitializer.java ├── BeanDescriptor.java ├── BeanInfo.java ├── Beans.java ├── ChangeListenerMap.java ├── ConstructorProperties.java ├── Customizer.java ├── DefaultPersistenceDelegate.java ├── DesignMode.java ├── Encoder.java ├── EventHandler.java ├── EventSetDescriptor.java ├── ExceptionListener.java ├── Expression.java ├── FeatureDescriptor.java ├── IndexedPropertyChangeEvent.java ├── IndexedPropertyDescriptor.java ├── IntrospectionException.java ├── Introspector.java ├── MetaData.java ├── MethodDescriptor.java ├── MethodRef.java ├── NameGenerator.java ├── ParameterDescriptor.java ├── PersistenceDelegate.java ├── PropertyChangeEvent.java ├── PropertyChangeListener.java ├── PropertyChangeListenerProxy.java ├── PropertyChangeSupport.java ├── PropertyDescriptor.java ├── PropertyEditor.java ├── PropertyEditorManager.java ├── PropertyEditorSupport.java ├── PropertyVetoException.java ├── SimpleBeanInfo.java ├── Statement.java ├── ThreadGroupContext.java ├── Transient.java ├── VetoableChangeListener.java ├── VetoableChangeListenerProxy.java ├── VetoableChangeSupport.java ├── Visibility.java ├── WeakIdentityMap.java ├── XMLDecoder.java ├── XMLEncoder.java └── beancontext ├── BeanContext.java ├── BeanContextChild.java ├── BeanContextChildComponentProxy.java ├── BeanContextChildSupport.java ├── BeanContextContainerProxy.java ├── BeanContextEvent.java ├── BeanContextMembershipEvent.java ├── BeanContextMembershipListener.java ├── BeanContextProxy.java ├── BeanContextServiceAvailableEvent.java ├── BeanContextServiceProvider.java ├── BeanContextServiceProviderBeanInfo.java ├── BeanContextServiceRevokedEvent.java ├── BeanContextServiceRevokedListener.java ├── BeanContextServices.java ├── BeanContextServicesListener.java ├── BeanContextServicesSupport.java └── BeanContextSupport.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.security.*】 - README]]></title>
    <url>%2Fjava.security%2FREADME%2F</url>
    <content type="text"><![CDATA[123456java.security（安全相关） ├── acl（此包中的类和接口已被java.security包中的类取代。） ├── cert（提供用于解析和管理证书，证书吊销列表（CRL）和证书路径的类和接口。） ├── interfaces（提供用于生成RSA实验室技术说明PKCS＃1中定义的RSA 密钥的接口，以及NIST的FIPS-186中定义的DSA（数字签名算法）密钥。） ├── spec（提供关键规范和算法参数规范的类和接口） └─ *.java（安全相关基础类） 包简介提供安全框架的类和接口。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183java.security ├── AccessControlContext.java ├── AccessControlException.java ├── AccessController.java ├── AlgorithmConstraints.java ├── AlgorithmParameterGenerator.java ├── AlgorithmParameterGeneratorSpi.java ├── AlgorithmParameters.java ├── AlgorithmParametersSpi.java ├── AllPermission.java ├── AuthProvider.java ├── BasicPermission.java ├── Certificate.java ├── CodeSigner.java ├── CodeSource.java ├── CryptoPrimitive.java ├── DigestException.java ├── DigestInputStream.java ├── DigestOutputStream.java ├── DomainCombiner.java ├── DomainLoadStoreParameter.java ├── GeneralSecurityException.java ├── Guard.java ├── GuardedObject.java ├── Identity.java ├── IdentityScope.java ├── InvalidAlgorithmParameterException.java ├── InvalidKeyException.java ├── InvalidParameterException.java ├── Key.java ├── KeyException.java ├── KeyFactory.java ├── KeyFactorySpi.java ├── KeyManagementException.java ├── KeyPair.java ├── KeyPairGenerator.java ├── KeyPairGeneratorSpi.java ├── KeyRep.java ├── KeyStore.java ├── KeyStoreException.java ├── KeyStoreSpi.java ├── MessageDigest.java ├── MessageDigestSpi.java ├── NoSuchAlgorithmException.java ├── NoSuchProviderException.java ├── PKCS12Attribute.java ├── Permission.java ├── PermissionCollection.java ├── Permissions.java ├── Policy.java ├── PolicySpi.java ├── Principal.java ├── PrivateKey.java ├── PrivilegedAction.java ├── PrivilegedActionException.java ├── PrivilegedExceptionAction.java ├── ProtectionDomain.java ├── Provider.java ├── ProviderException.java ├── PublicKey.java ├── SecureClassLoader.java ├── SecureRandom.java ├── SecureRandomSpi.java ├── Security.java ├── SecurityPermission.java ├── Signature.java ├── SignatureException.java ├── SignatureSpi.java ├── SignedObject.java ├── Signer.java ├── Timestamp.java ├── URIParameter.java ├── UnrecoverableEntryException.java ├── UnrecoverableKeyException.java ├── UnresolvedPermission.java ├── UnresolvedPermissionCollection.java ├── acl │ ├── Acl.java │ ├── AclEntry.java │ ├── AclNotFoundException.java │ ├── Group.java │ ├── LastOwnerException.java │ ├── NotOwnerException.java │ ├── Owner.java │ ├── Permission.java │ └── package-info.java ├── cert │ ├── CRL.java │ ├── CRLException.java │ ├── CRLReason.java │ ├── CRLSelector.java │ ├── CertPath.java │ ├── CertPathBuilder.java │ ├── CertPathBuilderException.java │ ├── CertPathBuilderResult.java │ ├── CertPathBuilderSpi.java │ ├── CertPathChecker.java │ ├── CertPathHelperImpl.java │ ├── CertPathParameters.java │ ├── CertPathValidator.java │ ├── CertPathValidatorException.java │ ├── CertPathValidatorResult.java │ ├── CertPathValidatorSpi.java │ ├── CertSelector.java │ ├── CertStore.java │ ├── CertStoreException.java │ ├── CertStoreParameters.java │ ├── CertStoreSpi.java │ ├── Certificate.java │ ├── CertificateEncodingException.java │ ├── CertificateException.java │ ├── CertificateExpiredException.java │ ├── CertificateFactory.java │ ├── CertificateFactorySpi.java │ ├── CertificateNotYetValidException.java │ ├── CertificateParsingException.java │ ├── CertificateRevokedException.java │ ├── CollectionCertStoreParameters.java │ ├── Extension.java │ ├── LDAPCertStoreParameters.java │ ├── PKIXBuilderParameters.java │ ├── PKIXCertPathBuilderResult.java │ ├── PKIXCertPathChecker.java │ ├── PKIXCertPathValidatorResult.java │ ├── PKIXParameters.java │ ├── PKIXReason.java │ ├── PKIXRevocationChecker.java │ ├── PolicyNode.java │ ├── PolicyQualifierInfo.java │ ├── TrustAnchor.java │ ├── X509CRL.java │ ├── X509CRLEntry.java │ ├── X509CRLSelector.java │ ├── X509CertSelector.java │ ├── X509Certificate.java │ ├── X509Extension.java │ └── package-info.java ├── interfaces │ ├── DSAKey.java │ ├── DSAKeyPairGenerator.java │ ├── DSAParams.java │ ├── DSAPrivateKey.java │ ├── DSAPublicKey.java │ ├── ECKey.java │ ├── ECPrivateKey.java │ ├── ECPublicKey.java │ ├── RSAKey.java │ ├── RSAMultiPrimePrivateCrtKey.java │ ├── RSAPrivateCrtKey.java │ ├── RSAPrivateKey.java │ ├── RSAPublicKey.java │ └── package-info.java ├── package-info.java └── spec ├── AlgorithmParameterSpec.java ├── DSAGenParameterSpec.java ├── DSAParameterSpec.java ├── DSAPrivateKeySpec.java ├── DSAPublicKeySpec.java ├── ECField.java ├── ECFieldF2m.java ├── ECFieldFp.java ├── ECGenParameterSpec.java ├── ECParameterSpec.java ├── ECPoint.java ├── ECPrivateKeySpec.java ├── ECPublicKeySpec.java ├── EllipticCurve.java ├── EncodedKeySpec.java ├── InvalidKeySpecException.java ├── InvalidParameterSpecException.java ├── KeySpec.java ├── MGF1ParameterSpec.java ├── PKCS8EncodedKeySpec.java ├── PSSParameterSpec.java ├── RSAKeyGenParameterSpec.java ├── RSAMultiPrimePrivateCrtKeySpec.java ├── RSAOtherPrimeInfo.java ├── RSAPrivateCrtKeySpec.java ├── RSAPrivateKeySpec.java ├── RSAPublicKeySpec.java ├── X509EncodedKeySpec.java └── package-info.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.rim.*】 - README]]></title>
    <url>%2Fjava.rim%2FREADME%2F</url>
    <content type="text"><![CDATA[123456java.rim（远程调用相关） ├── activation（提供对RMI对象激活的支持） ├── dgc（为RMI分布式垃圾收集（DGC）提供类和接口） ├── registry（为RMI注册表提供一个类和两个接口） ├── server（提供用于支持RMI服务器端的类和接口） └─ *.java（远程调用相关基础类） 包简介提供 RMI 包。RMI 指的是远程方法调用 (Remote Method Invocation)。 它是一种机制，能够让在某个 Java虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。 可以用此方法调用的任何对象必须实现该远程接口。调用这样一个对象时，其参数为 “marshalled” 并将其从本地虚拟机发送到远程虚拟机（该远程虚拟机的参数为 “unmarshalled”）上。 该方法终止时，将编组来自远程机的结果并将结果发送到调用方的虚拟机。如果方法调用导致抛出异常，则该异常将指示给调用方。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172java.rim ├── AccessException.java ├── AlreadyBoundException.java ├── ConnectException.java ├── ConnectIOException.java ├── MarshalException.java ├── MarshalledObject.java ├── Naming.java ├── NoSuchObjectException.java ├── NotBoundException.java ├── RMISecurityException.java ├── RMISecurityManager.java ├── Remote.java ├── RemoteException.java ├── ServerError.java ├── ServerException.java ├── ServerRuntimeException.java ├── StubNotFoundException.java ├── UnexpectedException.java ├── UnknownHostException.java ├── UnmarshalException.java ├── activation │ ├── Activatable.java │ ├── ActivateFailedException.java │ ├── ActivationDesc.java │ ├── ActivationException.java │ ├── ActivationGroup.java │ ├── ActivationGroupDesc.java │ ├── ActivationGroupID.java │ ├── ActivationID.java │ ├── ActivationInstantiator.java │ ├── ActivationMonitor.java │ ├── ActivationSystem.java │ ├── Activator.java │ ├── UnknownGroupException.java │ └── UnknownObjectException.java ├── dgc │ ├── DGC.java │ ├── Lease.java │ └── VMID.java ├── registry │ ├── LocateRegistry.java │ ├── Registry.java │ └── RegistryHandler.java └── server ├── ExportException.java ├── LoaderHandler.java ├── LogStream.java ├── ObjID.java ├── Operation.java ├── RMIClassLoader.java ├── RMIClassLoaderSpi.java ├── RMIClientSocketFactory.java ├── RMIFailureHandler.java ├── RMIServerSocketFactory.java ├── RMISocketFactory.java ├── RemoteCall.java ├── RemoteObject.java ├── RemoteObjectInvocationHandler.java ├── RemoteRef.java ├── RemoteServer.java ├── RemoteStub.java ├── ServerCloneException.java ├── ServerNotActiveException.java ├── ServerRef.java ├── Skeleton.java ├── SkeletonMismatchException.java ├── SkeletonNotFoundException.java ├── SocketSecurityException.java ├── UID.java ├── UnicastRemoteObject.java └── Unreferenced.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.nio.*】 - README]]></title>
    <url>%2Fjava.nio%2FREADME%2F</url>
    <content type="text"><![CDATA[123456789java.nio（bean相关的类） ├── channels（定义通道，表示与能够执行 I/O 操作的实体的连接，例如文件和套接字; 定义选择器，用于多路复用，非阻塞 I/O 操作。） │ └── spi（channels 服务提供类） ├── charset（定义字符集，解码器和编码器，用于在字节和Unicode字符之间进行转换。） │ └── spi（charset 服务提供类） ├── file（定义Java虚拟机的接口和类，以访问文件，文件属性和文件系统。） │ ├── attribute（提供对文件和文件系统属性的访问的接口和类。） │ └── spi（file 服务提供类） └─ *.java（缓冲区操作相关类） 包简介定义缓冲区等数据的容器，并提供其他 NIO包 的概述。 详细目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465java.nio ├── AppletInitializer.java ├── BeanDescriptor.java ├── BeanInfo.java ├── Beans.java ├── ChangeListenerMap.java ├── ConstructorProperties.java ├── Customizer.java ├── DefaultPersistenceDelegate.java ├── DesignMode.java ├── Encoder.java ├── EventHandler.java ├── EventSetDescriptor.java ├── ExceptionListener.java ├── Expression.java ├── FeatureDescriptor.java ├── IndexedPropertyChangeEvent.java ├── IndexedPropertyDescriptor.java ├── IntrospectionException.java ├── Introspector.java ├── MetaData.java ├── MethodDescriptor.java ├── MethodRef.java ├── NameGenerator.java ├── ParameterDescriptor.java ├── PersistenceDelegate.java ├── PropertyChangeEvent.java ├── PropertyChangeListener.java ├── PropertyChangeListenerProxy.java ├── PropertyChangeSupport.java ├── PropertyDescriptor.java ├── PropertyEditor.java ├── PropertyEditorManager.java ├── PropertyEditorSupport.java ├── PropertyVetoException.java ├── SimpleBeanInfo.java ├── Statement.java ├── ThreadGroupContext.java ├── Transient.java ├── VetoableChangeListener.java ├── VetoableChangeListenerProxy.java ├── VetoableChangeSupport.java ├── Visibility.java ├── WeakIdentityMap.java ├── XMLDecoder.java ├── XMLEncoder.java └── beancontext ├── BeanContext.java ├── BeanContextChild.java ├── BeanContextChildComponentProxy.java ├── BeanContextChildSupport.java ├── BeanContextContainerProxy.java ├── BeanContextEvent.java ├── BeanContextMembershipEvent.java ├── BeanContextMembershipListener.java ├── BeanContextProxy.java ├── BeanContextServiceAvailableEvent.java ├── BeanContextServiceProvider.java ├── BeanContextServiceProviderBeanInfo.java ├── BeanContextServiceRevokedEvent.java ├── BeanContextServiceRevokedListener.java ├── BeanContextServices.java ├── BeanContextServicesListener.java ├── BeanContextServicesSupport.java └── BeanContextSupport.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.net.*】 - README]]></title>
    <url>%2Fjava.net%2FREADME%2F</url>
    <content type="text"><![CDATA[12java.net（网络编程相关） └─ *.java（网络编程相关的类） 包简介提供网络应用程序的类。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384java.net ├── AbstractPlainDatagramSocketImpl.java ├── AbstractPlainSocketImpl.java ├── Authenticator.java ├── BindException.java ├── CacheRequest.java ├── CacheResponse.java ├── ConnectException.java ├── ContentHandler.java ├── ContentHandlerFactory.java ├── CookieHandler.java ├── CookieManager.java ├── CookiePolicy.java ├── CookieStore.java ├── DatagramPacket.java ├── DatagramSocket.java ├── DatagramSocketImpl.java ├── DatagramSocketImplFactory.java ├── DefaultDatagramSocketImplFactory.java ├── DefaultInterface.java ├── FileNameMap.java ├── HostPortrange.java ├── HttpConnectSocketImpl.java ├── HttpCookie.java ├── HttpRetryException.java ├── HttpURLConnection.java ├── IDN.java ├── InMemoryCookieStore.java ├── Inet4Address.java ├── Inet4AddressImpl.java ├── Inet6Address.java ├── Inet6AddressImpl.java ├── InetAddress.java ├── InetAddressContainer.java ├── InetAddressImpl.java ├── InetSocketAddress.java ├── InterfaceAddress.java ├── JarURLConnection.java ├── MalformedURLException.java ├── MulticastSocket.java ├── NetPermission.java ├── NetworkInterface.java ├── NoRouteToHostException.java ├── PasswordAuthentication.java ├── PlainDatagramSocketImpl.java ├── PlainSocketImpl.java ├── PortUnreachableException.java ├── ProtocolException.java ├── ProtocolFamily.java ├── Proxy.java ├── ProxySelector.java ├── ResponseCache.java ├── SdpSocketImpl.java ├── SecureCacheResponse.java ├── ServerSocket.java ├── Socket.java ├── SocketAddress.java ├── SocketException.java ├── SocketImpl.java ├── SocketImplFactory.java ├── SocketInputStream.java ├── SocketOption.java ├── SocketOptions.java ├── SocketOutputStream.java ├── SocketPermission.java ├── SocketSecrets.java ├── SocketTimeoutException.java ├── SocksConsts.java ├── SocksSocketImpl.java ├── StandardProtocolFamily.java ├── StandardSocketOptions.java ├── URI.java ├── URISyntaxException.java ├── URL.java ├── URLClassLoader.java ├── URLConnection.java ├── URLDecoder.java ├── URLEncoder.java ├── URLPermission.java ├── URLStreamHandler.java ├── URLStreamHandlerFactory.java ├── UnknownHostException.java ├── UnknownServiceException.java └── package-info.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.io.*】 - README]]></title>
    <url>%2Fjava.io%2FREADME%2F</url>
    <content type="text"><![CDATA[12java.io（数据流操作） └─ *.java（序列化和文件系统提供系统输入和输出的类） 包简介通过数据流，序列化和文件系统提供系统输入和输出。除非另有说明，否则将null参数传递给此包中任何类或接口中的构造函数或方法将导致 NullPointerException抛出。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687java.io ├── Bits.java ├── BufferedInputStream.java ├── BufferedOutputStream.java ├── BufferedReader.java ├── BufferedWriter.java ├── ByteArrayInputStream.java ├── ByteArrayOutputStream.java ├── CharArrayReader.java ├── CharArrayWriter.java ├── CharConversionException.java ├── Closeable.java ├── Console.java ├── DataInput.java ├── DataInputStream.java ├── DataOutput.java ├── DataOutputStream.java ├── DefaultFileSystem.java ├── DeleteOnExitHook.java ├── EOFException.java ├── ExpiringCache.java ├── Externalizable.java ├── File.java ├── FileDescriptor.java ├── FileFilter.java ├── FileInputStream.java ├── FileNotFoundException.java ├── FileOutputStream.java ├── FilePermission.java ├── FileReader.java ├── FileSystem.java ├── FileWriter.java ├── FilenameFilter.java ├── FilterInputStream.java ├── FilterOutputStream.java ├── FilterReader.java ├── FilterWriter.java ├── Flushable.java ├── IOError.java ├── IOException.java ├── InputStream.java ├── InputStreamReader.java ├── InterruptedIOException.java ├── InvalidClassException.java ├── InvalidObjectException.java ├── LineNumberInputStream.java ├── LineNumberReader.java ├── NotActiveException.java ├── NotSerializableException.java ├── ObjectInput.java ├── ObjectInputStream.java ├── ObjectInputValidation.java ├── ObjectOutput.java ├── ObjectOutputStream.java ├── ObjectStreamClass.java ├── ObjectStreamConstants.java ├── ObjectStreamException.java ├── ObjectStreamField.java ├── OptionalDataException.java ├── OutputStream.java ├── OutputStreamWriter.java ├── PipedInputStream.java ├── PipedOutputStream.java ├── PipedReader.java ├── PipedWriter.java ├── PrintStream.java ├── PrintWriter.java ├── PushbackInputStream.java ├── PushbackReader.java ├── RandomAccessFile.java ├── Reader.java ├── SequenceInputStream.java ├── SerialCallbackContext.java ├── Serializable.java ├── SerializablePermission.java ├── StreamCorruptedException.java ├── StreamTokenizer.java ├── StringBufferInputStream.java ├── StringReader.java ├── StringWriter.java ├── SyncFailedException.java ├── UTFDataFormatException.java ├── UncheckedIOException.java ├── UnixFileSystem.java ├── UnsupportedEncodingException.java ├── WriteAbortedException.java └── Writer.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.math.*】 - README]]></title>
    <url>%2Fjava.math%2FREADME%2F</url>
    <content type="text"><![CDATA[12java.math（高精度计算） └─ *.java（高精度计算相关类） 包简介提供用于执行任意精度整数算术（BigInteger）和任意精度十进制算术（BigDecimal）的类。 BigInteger类似于原始整数类型，除了它提供任意精度，因此对BigIntegers的操作不会溢出或丢失精度。除标准算术运算外， BigInteger还提供模运算，GCD计算，素数测试，素数生成，位操作以及一些其他杂项操作。 BigDecimal提供适合于货币计算等的任意精度的带符号十进制数。 BigDecimal使用户可以完全控制舍入行为，允许用户从一组全面的八种舍入模式中进行选择。 详细目录123456789java.math ├── BigDecimal.java ├── BigInteger.java ├── BitSieve.java ├── MathContext.java ├── MutableBigInteger.java ├── RoundingMode.java ├── SignedMutableBigInteger.java └── package-info.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.lang.*】 - README]]></title>
    <url>%2Fjava.lang%2FREADME%2F</url>
    <content type="text"><![CDATA[12345678java.lang（提供对Java编程语言设计至关重要的类） ├── annotation（通用注解类） ├── instrument（自定义代理基础类-动态语言支持） ├── invoke（方法句柄相关基础类-动态语言支持） ├── management（JVM监测和管理相关基础类） ├── ref（引用对象类-支持与垃圾收集器的有限程度的交互） ├── reflect（反射编程相关） └─ *.java（Java编程基础类） 包简介提供对Java编程语言设计至关重要的类。最重要的类是 Object类层次结构的根，并且其 Class实例在运行时表示类。 通常，有必要将原始类型的值表示为对象。该包装类Boolean， Character，Integer，Long，Float，和Double服务于这个目的。 Double例如，类型的对象包含一个类型为double的字段，以这样的方式表示该值，即对它的引用可以存储在引用类型的变量中。这些类还提供了许多用于在原始值之间进行转换的方法，以及支持诸如equals和hashCode之类的标准方法。的 Void类是保持于基准的非实例化类Class代表类型void对象。 该类Math提供常用的数学函数，如正弦，余弦和平方根。类 String，StringBuffer以及StringBuilder类似地提供字符串上常用的操作。 类ClassLoader，Process， ProcessBuilder，Runtime，SecurityManager，并 System提供了管理类的动态加载，创造外部进程中，主机环境查询，如一天中的时间，以及安全策略的执行“系统操作”。 类Throwable包含throw语句可能抛出的对象。Throwable 表示错误和异常的子类。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243java.lang ├── AbstractMethodError.java ├── AbstractStringBuilder.java ├── Appendable.java ├── ApplicationShutdownHooks.java ├── ArithmeticException.java ├── ArrayIndexOutOfBoundsException.java ├── ArrayStoreException.java ├── AssertionError.java ├── AssertionStatusDirectives.java ├── AutoCloseable.java ├── Boolean.java ├── BootstrapMethodError.java ├── Byte.java ├── CharSequence.java ├── Character.java ├── CharacterData.java ├── CharacterData00.java ├── CharacterData01.java ├── CharacterData02.java ├── CharacterData0E.java ├── CharacterDataLatin1.java ├── CharacterDataPrivateUse.java ├── CharacterDataUndefined.java ├── CharacterName.java ├── Class.java ├── ClassCastException.java ├── ClassCircularityError.java ├── ClassFormatError.java ├── ClassLoader.java ├── ClassLoaderHelper.java ├── ClassNotFoundException.java ├── ClassValue.java ├── CloneNotSupportedException.java ├── Cloneable.java ├── Comparable.java ├── Compiler.java ├── ConditionalSpecialCasing.java ├── Deprecated.java ├── Double.java ├── Enum.java ├── EnumConstantNotPresentException.java ├── Error.java ├── Exception.java ├── ExceptionInInitializerError.java ├── Float.java ├── FunctionalInterface.java ├── IllegalAccessError.java ├── IllegalAccessException.java ├── IllegalArgumentException.java ├── IllegalMonitorStateException.java ├── IllegalStateException.java ├── IllegalThreadStateException.java ├── IncompatibleClassChangeError.java ├── IndexOutOfBoundsException.java ├── InheritableThreadLocal.java ├── InstantiationError.java ├── InstantiationException.java ├── Integer.java ├── InternalError.java ├── InterruptedException.java ├── Iterable.java ├── LinkageError.java ├── Long.java ├── Math.java ├── NegativeArraySizeException.java ├── NoClassDefFoundError.java ├── NoSuchFieldError.java ├── NoSuchFieldException.java ├── NoSuchMethodError.java ├── NoSuchMethodException.java ├── NullPointerException.java ├── Number.java ├── NumberFormatException.java ├── Object.java ├── OutOfMemoryError.java ├── Override.java ├── Package.java ├── Process.java ├── ProcessBuilder.java ├── ProcessEnvironment.java ├── ProcessImpl.java ├── Readable.java ├── ReflectiveOperationException.java ├── Runnable.java ├── Runtime.java ├── RuntimeException.java ├── RuntimePermission.java ├── SafeVarargs.java ├── SecurityException.java ├── SecurityManager.java ├── Short.java ├── Shutdown.java ├── StackOverflowError.java ├── StackTraceElement.java ├── StrictMath.java ├── String.java ├── StringBuffer.java ├── StringBuilder.java ├── StringCoding.java ├── StringIndexOutOfBoundsException.java ├── SuppressWarnings.java ├── System.java ├── Terminator.java ├── Thread.java ├── ThreadDeath.java ├── ThreadGroup.java ├── ThreadLocal.java ├── Throwable.java ├── TypeNotPresentException.java ├── UNIXProcess.java ├── UnknownError.java ├── UnsatisfiedLinkError.java ├── UnsupportedClassVersionError.java ├── UnsupportedOperationException.java ├── VerifyError.java ├── VirtualMachineError.java ├── Void.java ├── annotation │ ├── Annotation.java │ ├── AnnotationFormatError.java │ ├── AnnotationTypeMismatchException.java │ ├── Documented.java │ ├── ElementType.java │ ├── IncompleteAnnotationException.java │ ├── Inherited.java │ ├── Native.java │ ├── Repeatable.java │ ├── Retention.java │ ├── RetentionPolicy.java │ ├── Target.java │ └── package-info.java ├── instrument │ ├── ClassDefinition.java │ ├── ClassFileTransformer.java │ ├── IllegalClassFormatException.java │ ├── Instrumentation.java │ └── UnmodifiableClassException.java ├── invoke │ ├── AbstractValidatingLambdaMetafactory.java │ ├── BoundMethodHandle.java │ ├── CallSite.java │ ├── ConstantCallSite.java │ ├── DelegatingMethodHandle.java │ ├── DirectMethodHandle.java │ ├── DontInline.java │ ├── ForceInline.java │ ├── InfoFromMemberName.java │ ├── InjectedProfile.java │ ├── InnerClassLambdaMetafactory.java │ ├── InvokeDynamic.java │ ├── InvokerBytecodeGenerator.java │ ├── Invokers.java │ ├── LambdaConversionException.java │ ├── LambdaForm.java │ ├── LambdaFormBuffer.java │ ├── LambdaFormEditor.java │ ├── LambdaMetafactory.java │ ├── MemberName.java │ ├── MethodHandle.java │ ├── MethodHandleImpl.java │ ├── MethodHandleInfo.java │ ├── MethodHandleNatives.java │ ├── MethodHandleProxies.java │ ├── MethodHandleStatics.java │ ├── MethodHandles.java │ ├── MethodType.java │ ├── MethodTypeForm.java │ ├── MutableCallSite.java │ ├── ProxyClassesDumper.java │ ├── SerializedLambda.java │ ├── SimpleMethodHandle.java │ ├── Stable.java │ ├── SwitchPoint.java │ ├── TypeConvertingMethodAdapter.java │ ├── VolatileCallSite.java │ ├── WrongMethodTypeException.java │ └── package-info.java ├── management │ ├── BufferPoolMXBean.java │ ├── ClassLoadingMXBean.java │ ├── CompilationMXBean.java │ ├── GarbageCollectorMXBean.java │ ├── LockInfo.java │ ├── ManagementFactory.java │ ├── ManagementPermission.java │ ├── MemoryMXBean.java │ ├── MemoryManagerMXBean.java │ ├── MemoryNotificationInfo.java │ ├── MemoryPoolMXBean.java │ ├── MemoryType.java │ ├── MemoryUsage.java │ ├── MonitorInfo.java │ ├── OperatingSystemMXBean.java │ ├── PlatformComponent.java │ ├── PlatformLoggingMXBean.java │ ├── PlatformManagedObject.java │ ├── RuntimeMXBean.java │ ├── ThreadInfo.java │ └── ThreadMXBean.java ├── package-info.java ├── ref │ ├── FinalReference.java │ ├── Finalizer.java │ ├── FinalizerHistogram.java │ ├── PhantomReference.java │ ├── Reference.java │ ├── ReferenceQueue.java │ ├── SoftReference.java │ └── WeakReference.java └── reflect ├── AccessibleObject.java ├── AnnotatedArrayType.java ├── AnnotatedElement.java ├── AnnotatedParameterizedType.java ├── AnnotatedType.java ├── AnnotatedTypeVariable.java ├── AnnotatedWildcardType.java ├── Array.java ├── Constructor.java ├── Executable.java ├── Field.java ├── GenericArrayType.java ├── GenericDeclaration.java ├── GenericSignatureFormatError.java ├── InvocationHandler.java ├── InvocationTargetException.java ├── MalformedParameterizedTypeException.java ├── MalformedParametersException.java ├── Member.java ├── Method.java ├── Modifier.java ├── Parameter.java ├── ParameterizedType.java ├── Proxy.java ├── ReflectAccess.java ├── ReflectPermission.java ├── Type.java ├── TypeVariable.java ├── UndeclaredThrowableException.java ├── WeakCache.java ├── WildcardType.java └── package-info.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.util.*】 - README]]></title>
    <url>%2Fjava.util%2FREADME%2F</url>
    <content type="text"><![CDATA[123456789101112├─concurrent(多线程）│ ├─atomic（原子操作）│ └─locks（锁）├─function（Function接口）├─jar（jar工具）├─logging（日志组件）├─prefs（首选项工具）├─regex（正则）├─spi（服务提供发现机制）├─stream（Lambda流编程）├─zip（压缩工具）└─*.java（集合工具） 包简介java.util.* 是 java 的常用工具类，包含 collection 框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 详细目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387java.util ├─AbstractCollection.java ├─AbstractList.java ├─AbstractMap.java ├─AbstractQueue.java ├─AbstractSequentialList.java ├─AbstractSet.java ├─ArrayDeque.java ├─ArrayList.java ├─ArrayPrefixHelpers.java ├─Arrays.java ├─ArraysParallelSortHelpers.java ├─Base64.java ├─BitSet.java ├─Calendar.java ├─Collection.java ├─Collections.java ├─ComparableTimSort.java ├─Comparator.java ├─Comparators.java ├─ConcurrentModificationException.java ├─Currency.java ├─Date.java ├─Deque.java ├─Dictionary.java ├─DoubleSummaryStatistics.java ├─DualPivotQuicksort.java ├─DuplicateFormatFlagsException.java ├─EmptyStackException.java ├─Enumeration.java ├─EnumMap.java ├─EnumSet.java ├─EventListener.java ├─EventListenerProxy.java ├─EventObject.java ├─FormatFlagsConversionMismatchException.java ├─Formattable.java ├─FormattableFlags.java ├─Formatter.java ├─FormatterClosedException.java ├─GregorianCalendar.java ├─HashMap.java ├─HashSet.java ├─Hashtable.java ├─IdentityHashMap.java ├─IllegalFormatCodePointException.java ├─IllegalFormatConversionException.java ├─IllegalFormatException.java ├─IllegalFormatFlagsException.java ├─IllegalFormatPrecisionException.java ├─IllegalFormatWidthException.java ├─IllformedLocaleException.java ├─InputMismatchException.java ├─IntSummaryStatistics.java ├─InvalidPropertiesFormatException.java ├─Iterator.java ├─JapaneseImperialCalendar.java ├─JumboEnumSet.java ├─LinkedHashMap.java ├─LinkedHashSet.java ├─LinkedList.java ├─List.java ├─ListIterator.java ├─ListResourceBundle.java ├─Locale.java ├─LocaleISOData.java ├─LongSummaryStatistics.java ├─Map.java ├─MissingFormatArgumentException.java ├─MissingFormatWidthException.java ├─MissingResourceException.java ├─NavigableMap.java ├─NavigableSet.java ├─NoSuchElementException.java ├─Objects.java ├─Observable.java ├─Observer.java ├─Optional.java ├─OptionalDouble.java ├─OptionalInt.java ├─OptionalLong.java ├─PrimitiveIterator.java ├─PriorityQueue.java ├─Properties.java ├─PropertyPermission.java ├─PropertyResourceBundle.java ├─Queue.java ├─Random.java ├─RandomAccess.java ├─RegularEnumSet.java ├─ResourceBundle.java ├─Scanner.java ├─ServiceConfigurationError.java ├─ServiceLoader.java ├─Set.java ├─SimpleTimeZone.java ├─SortedMap.java ├─SortedSet.java ├─Spliterator.java ├─Spliterators.java ├─SplittableRandom.java ├─Stack.java ├─StringJoiner.java ├─StringTokenizer.java ├─Timer.java ├─TimerTask.java ├─TimeZone.java ├─TimSort.java ├─TooManyListenersException.java ├─TreeMap.java ├─TreeSet.java ├─Tripwire.java ├─UnknownFormatConversionException.java ├─UnknownFormatFlagsException.java ├─UUID.java ├─Vector.java ├─WeakHashMap.java │ ├─concurrent │ ├─AbstractExecutorService.java │ ├─ArrayBlockingQueue.java │ ├─BlockingDeque.java │ ├─BlockingQueue.java │ ├─BrokenBarrierException.java │ ├─Callable.java │ ├─CancellationException.java │ ├─CompletableFuture.java │ ├─CompletionException.java │ ├─CompletionService.java │ ├─CompletionStage.java │ ├─ConcurrentHashMap.java │ ├─ConcurrentLinkedDeque.java │ ├─ConcurrentLinkedQueue.java │ ├─ConcurrentMap.java │ ├─ConcurrentNavigableMap.java │ ├─ConcurrentSkipListMap.java │ ├─ConcurrentSkipListSet.java │ ├─CopyOnWriteArrayList.java │ ├─CopyOnWriteArraySet.java │ ├─CountDownLatch.java │ ├─CountedCompleter.java │ ├─CyclicBarrier.java │ ├─Delayed.java │ ├─DelayQueue.java │ ├─Exchanger.java │ ├─ExecutionException.java │ ├─Executor.java │ ├─ExecutorCompletionService.java │ ├─Executors.java │ ├─ExecutorService.java │ ├─ForkJoinPool.java │ ├─ForkJoinTask.java │ ├─ForkJoinWorkerThread.java │ ├─Future.java │ ├─FutureTask.java │ ├─LinkedBlockingDeque.java │ ├─LinkedBlockingQueue.java │ ├─LinkedTransferQueue.java │ ├─package-info.java │ ├─Phaser.java │ ├─PriorityBlockingQueue.java │ ├─RecursiveAction.java │ ├─RecursiveTask.java │ ├─RejectedExecutionException.java │ ├─RejectedExecutionHandler.java │ ├─RunnableFuture.java │ ├─RunnableScheduledFuture.java │ ├─ScheduledExecutorService.java │ ├─ScheduledFuture.java │ ├─ScheduledThreadPoolExecutor.java │ ├─Semaphore.java │ ├─SynchronousQueue.java │ ├─ThreadFactory.java │ ├─ThreadLocalRandom.java │ ├─ThreadPoolExecutor.java │ ├─TimeoutException.java │ ├─TimeUnit.java │ └─TransferQueue.java │ ├─atomic │ ├─AtomicBoolean.java │ ├─AtomicInteger.java │ ├─AtomicIntegerArray.java │ ├─AtomicIntegerFieldUpdater.java │ ├─AtomicLong.java │ ├─AtomicLongArray.java │ ├─AtomicLongFieldUpdater.java │ ├─AtomicMarkableReference.java │ ├─AtomicReference.java │ ├─AtomicReferenceArray.java │ ├─AtomicReferenceFieldUpdater.java │ ├─AtomicStampedReference.java │ ├─DoubleAccumulator.java │ ├─DoubleAdder.java │ ├─LongAccumulator.java │ ├─LongAdder.java │ ├─package-info.java │ └─Striped64.java │ ├─locks │ ├─AbstractOwnableSynchronizer.java │ ├─AbstractQueuedLongSynchronizer.java │ ├─AbstractQueuedSynchronizer.java │ ├─Condition.java │ ├─Lock.java │ ├─LockSupport.java │ ├─package-info.java │ ├─ReadWriteLock.java │ ├─ReentrantLock.java │ ├─ReentrantReadWriteLock.java │ └─StampedLock.java │ ├─function │ ├─BiConsumer.java │ ├─BiFunction.java │ ├─BinaryOperator.java │ ├─BiPredicate.java │ ├─BooleanSupplier.java │ ├─Consumer.java │ ├─DoubleBinaryOperator.java │ ├─DoubleConsumer.java │ ├─DoubleFunction.java │ ├─DoublePredicate.java │ ├─DoubleSupplier.java │ ├─DoubleToIntFunction.java │ ├─DoubleToLongFunction.java │ ├─DoubleUnaryOperator.java │ ├─Function.java │ ├─IntBinaryOperator.java │ ├─IntConsumer.java │ ├─IntFunction.java │ ├─IntPredicate.java │ ├─IntSupplier.java │ ├─IntToDoubleFunction.java │ ├─IntToLongFunction.java │ ├─IntUnaryOperator.java │ ├─LongBinaryOperator.java │ ├─LongConsumer.java │ ├─LongFunction.java │ ├─LongPredicate.java │ ├─LongSupplier.java │ ├─LongToDoubleFunction.java │ ├─LongToIntFunction.java │ ├─LongUnaryOperator.java │ ├─ObjDoubleConsumer.java │ ├─ObjIntConsumer.java │ ├─ObjLongConsumer.java │ ├─package-info.java │ ├─Predicate.java │ ├─Supplier.java │ ├─ToDoubleBiFunction.java │ ├─ToDoubleFunction.java │ ├─ToIntBiFunction.java │ ├─ToIntFunction.java │ ├─ToLongBiFunction.java │ ├─ToLongFunction.java │ └─UnaryOperator.java │ ├─jar │ ├─Attributes.java │ ├─JarEntry.java │ ├─JarException.java │ ├─JarFile.java │ ├─JarInputStream.java │ ├─JarOutputStream.java │ ├─JarVerifier.java │ ├─JavaUtilJarAccessImpl.java │ ├─Manifest.java │ └─Pack200.java │ ├─logging │ ├─ConsoleHandler.java │ ├─ErrorManager.java │ ├─FileHandler.java │ ├─Filter.java │ ├─Formatter.java │ ├─Handler.java │ ├─Level.java │ ├─Logger.java │ ├─Logging.java │ ├─LoggingMXBean.java │ ├─LoggingPermission.java │ ├─LoggingProxyImpl.java │ ├─LogManager.java │ ├─LogRecord.java │ ├─MemoryHandler.java │ ├─SimpleFormatter.java │ ├─SocketHandler.java │ ├─StreamHandler.java │ └─XMLFormatter.java │ ├─prefs │ ├─AbstractPreferences.java │ ├─BackingStoreException.java │ ├─Base64.java │ ├─FileSystemPreferences.java │ ├─FileSystemPreferencesFactory.java │ ├─InvalidPreferencesFormatException.java │ ├─NodeChangeEvent.java │ ├─NodeChangeListener.java │ ├─PreferenceChangeEvent.java │ ├─PreferenceChangeListener.java │ ├─Preferences.java │ ├─PreferencesFactory.java │ └─XmlSupport.java │ ├─regex │ ├─ASCII.java │ ├─Matcher.java │ ├─MatchResult.java │ ├─Pattern.java │ ├─PatternSyntaxException.java │ └─UnicodeProp.java │ ├─spi │ ├─CalendarDataProvider.java │ ├─CalendarNameProvider.java │ ├─CurrencyNameProvider.java │ ├─LocaleNameProvider.java │ ├─LocaleServiceProvider.java │ ├─ResourceBundleControlProvider.java │ └─TimeZoneNameProvider.java │ ├─stream │ ├─AbstractPipeline.java │ ├─AbstractShortCircuitTask.java │ ├─AbstractSpinedBuffer.java │ ├─AbstractTask.java │ ├─BaseStream.java │ ├─Collector.java │ ├─Collectors.java │ ├─DistinctOps.java │ ├─DoublePipeline.java │ ├─DoubleStream.java │ ├─FindOps.java │ ├─ForEachOps.java │ ├─IntPipeline.java │ ├─IntStream.java │ ├─LongPipeline.java │ ├─LongStream.java │ ├─MatchOps.java │ ├─Node.java │ ├─Nodes.java │ ├─package-info.java │ ├─PipelineHelper.java │ ├─ReduceOps.java │ ├─ReferencePipeline.java │ ├─Sink.java │ ├─SliceOps.java │ ├─SortedOps.java │ ├─SpinedBuffer.java │ ├─Stream.java │ ├─StreamOpFlag.java │ ├─Streams.java │ ├─StreamShape.java │ ├─StreamSpliterators.java │ ├─StreamSupport.java │ ├─TerminalOp.java │ ├─TerminalSink.java │ └─Tripwire.java │ └─zip ├─Adler32.java ├─CheckedInputStream.java ├─CheckedOutputStream.java ├─Checksum.java ├─CRC32.java ├─DataFormatException.java ├─Deflater.java ├─DeflaterInputStream.java ├─DeflaterOutputStream.java ├─GZIPInputStream.java ├─GZIPOutputStream.java ├─Inflater.java ├─InflaterInputStream.java ├─InflaterOutputStream.java ├─ZipCoder.java ├─ZipConstants.java ├─ZipConstants64.java ├─ZipEntry.java ├─ZipError.java ├─ZipException.java ├─ZipFile.java ├─ZipInputStream.java ├─ZipOutputStream.java ├─ZipUtils.java └─ZStreamRef.java]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.util.HashMap.java】 - 源码提要]]></title>
    <url>%2Fjava.util%2FHashMap%2F</url>
    <content type="text"><![CDATA[继承实现12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123;...&#125; AbstractMap1public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;...&#125; AbstractMap 抽象类实现了一些 Map 接口的简单且通用的方法 Map1public interface Map&lt;K,V&gt;&#123;...&#125; 定义键值对结构对象的通用操作，通过使用模板方式实现类或实例化时候可以动态自定义键（K）和值（V）类型 Cloneable12public interface Cloneable &#123;&#125; Cloneable 是标记型接口，它们内部都没有方法和属性，implements Cloneable表示该对象能被克隆，能使用 Object.clone() 方法。如果没有 implements Cloneable 的类调用 Object.clone() 方法就会抛出 CloneNotSupportedException。 Serializable12public interface Serializable &#123;&#125; 和 Cloneable 一样都是标记型接口，一个类只有实现了 Serializable 接口，它的对象才能被序列化 变量属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 持久化版本ID，用于 Serializable 的序列化。private static final long serialVersionUID = 362498820763181265L;/** * The default initial capacity - MUST be a power of two. * 初始容量 —— 必须是 2 的幂 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka（有名） 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * 最大容量，如果构造时候被指定更大的容量，这个就会被隐式指定为其容量。 * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. * 默认加载因子 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * 链改成树的阀值 */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 树变成链的阀值 */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * 可能树化的最小容量 * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;/** * The table, initialized on first use, and resized as * necessary. * 哈希桶 */transient Node&lt;K,V&gt;[] table;/** * Holds cached entrySet(). * 缓存第一次 entrySet()的指针 */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * The number of key-value mappings contained in this map. * key-value 映射的数量 */transient int size;/** * The number of times this HashMap has been structurally modified * 结构修改的次数 */transient int modCount;/** * The next size value at which to resize (capacity * load factor). * 扩容阀值 ，一次初始化就不能修改了 * @serial */int threshold;/** * The load factor for the hash table. * 加载因子，一次初始化就不能修改了 * @serial */final float loadFactor; static用来修饰变量表示类变量，一个类中某个属性被static所修饰，那么就可以通过”类名.属性名”来访问 final一旦定义了 final 变量并在首次为其显示初始化后，final修饰的变量值不可被改变。对于基础类型变量，值不能改变；对于引用类型变量，引用不能指向其他对象。 transient 只能修饰变量。 局部变量不能被 transient 关键字修饰，静态变量不管是否被 transient 修饰，均不能被序列化。 一旦变量被 transient 修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 HashMap 实现 Serializable 接口，搭配 transient 可以选择性的序列化变量，比如 entrySet 和 threshold 之类的就可以不用了。 内部类Node类123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;final int hash;final K key;V value;Node&lt;K,V&gt; next;Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next;&#125;public final K getKey() &#123; return key; &#125;public final V getValue() &#123; return value; &#125;public final String toString() &#123; return key + "=" + value; &#125;public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue;&#125;public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false;&#125;&#125; HashMap 的数据元节点，该类实现 Map.Entry 类，节点有 键-值 属性，Next 节点可以实现链式结构。 Node.hashCode 方法 Objects.hashCode 方法如下： 123public static int hashCode(Object o) &#123; return o != null ? o.hashCode() : 0;&#125; Object.hashCode 方法如下： 1public native int hashCode(); Object.hashCode 方法为 native 方法，通常是通过 C/C++ 本地方法库实现的，思路一般是将对象的内部地址转换成整数来实现。 用位运算生成新的 hashCode，其一是为了程序效率更快；其二用 ^ 异或运算，而不用与运算和或运算，是因为对象内部地址很紧凑，与和或运算很容易产生重复值，而异或运算有更好的散列性。 Node.setValue 方法 设置新值，返回旧值。这种编程思维，使得数据具有一次记忆反馈的特性，是一种可以参考的思想。 Node.equals 方法 重写该方法是扩展 equals 的含义，一般情况，对于自定义类对象有比较操作，都会重定义 equals 概念。 比如，判断两位公民账号是否为同一人，其身份证号一样即为同一人。 TreeNode 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; /** * Ensures that the given root is the first node of its bin. */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; /** * Calls find for root node. */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. */ static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; /** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; /** * Returns a list of non-TreeNodes replacing those linked from * this node. */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by "next" pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125;&#125; KeySet 类1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 该类继承自 AbstractSet，而AbstractSet 继承自 AbstractCollection，并且实现了 Set 接口。 1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123;...&#125;]]></content>
      <tags>
        <tag>源码提要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.util.HashMap.java】 - 源码翻译]]></title>
    <url>%2Fjava.util%2FHashMap.java-zh%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273227422752276227722782279228022812282228322842285228622872288228922902291229222932294229522962297229822992300230123022303230423052306230723082309231023112312231323142315231623172318231923202321232223232324232523262327232823292330233123322333233423352336233723382339234023412342234323442345234623472348234923502351235223532354235523562357235823592360236123622363236423652366236723682369237023712372237323742375237623772378237923802381238223832384238523862387238823892390239123922393239423952396239723982399240024012402240324042405240624072408240924102411/* * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. * 版权1997-2017，全部归属于 Oracle 和它的子公司 * ORACLE 专属/机密，使用许可条款。 */package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;import sun.misc.SharedSecrets;/** * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface. This * implementation provides all of the optional map operations, and permits * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key. (The &lt;tt&gt;HashMap&lt;/tt&gt; * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is * unsynchronized and permits nulls.) This class makes no guarantees as to * the order of the map; in particular, it does not guarantee that the order * will remain constant over time. * Hash 表基于 Map 接口实现。这个实现提供了所有的 map 操作，并且允许 null 值和 null 键。 * 除了非同步且允许 null，HashMap 类大致与 Hashtable 相同。 * * &lt;p&gt;This implementation provides constant-time performance for the basic * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function * disperses the elements properly among the buckets. Iteration over * collection views requires time proportional to the "capacity" of the * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number * of key-value mappings). Thus, it's very important not to set the initial * capacity too high (or the load factor too low) if iteration performance is * important. * 这个实现类在基础的 get 和 put 操作上，通过改进 hash 函数使元素在定位时更分散，性能上保证了稳定时间。 * 迭代遍历集合视图所用的时间和 HashMap 实例的 capacity（hash桶个数） + 实例的 size（键-值对映射的数量）成正比。 * 因此，对于迭代遍历性能很重要的，初始化的时候不能将 capacity 设置过高（或将加载因子设置过低）这点很重要。 * * &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. The * &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial * capacity is simply the capacity at the time the hash table is created. The * &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to * get before its capacity is automatically increased. When the number of * entries in the hash table exceeds the product of the load factor and the * current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data * structures are rebuilt) so that the hash table has approximately twice the * number of buckets. * 一个 HashMap 实例有两个参数影响它的性能：初始化容量和加载因子。 * 这个初始化容量是 hash 表中桶的数量，并且这个在 hash 表创建的时候就是单纯的容量。 * 随着容量内容自动增长，加载因子是衡量 hash 表是否满了。 * 当 hash 表的实体数量超过了当前容量和加载因子的乘积，hash 表就会 rehash（就是内部数据结构重构）， * 达到将近原来两倍的桶数。 * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good * tradeoff between time and space costs. Higher values decrease the * space overhead but increase the lookup cost (reflected in most of * the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including * &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;). The expected number of entries in * the map and its load factor should be taken into account when * setting its initial capacity, so as to minimize the number of * rehash operations. If the initial capacity is greater than the * maximum number of entries divided by the load factor, no rehash * operations will ever occur. * 通常，默认的加载因子（0.75）在时间和空间上做到了良好的平衡。过高的值虽然降低了空间开销，但是也 * 增加了查找的代价（对应大多数 HashMap 类的操作，包括 get 和 put）。如果确定了实体的数量， * 在初始化容量时候应该考虑加载因子的值，确保最少 rehash 操作。如果初始化容量大于实体数量除以加载因子的值，将不会 rehash * * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; * instance, creating it with a sufficiently large capacity will allow * the mappings to be stored more efficiently than letting it perform * automatic rehashing as needed to grow the table. Note that using * many keys with the same &#123;@code hashCode()&#125; is a sure way to slow * down performance of any hash table. To ameliorate impact, when keys * are &#123;@link Comparable&#125;, this class may use comparison order among * keys to help break ties. * 记住，如果很多映射关系要存储在 HashMap 实例中，相比安需自动扩容，创建一个足够大的容量实例将允许这些映射关系更高效的存储。 * 使用大多数键相同的 &#123;@code hashCode()&#125; 方法，理所当然的会减低 hash 表的性能。 * 为了改善这个情况，当发生键比较的时候，这个类将使用有序的比较指令打破原有的联系。 * * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access a hash map concurrently, and at least one of * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be * synchronized externally. (A structural modification is any operation * that adds or deletes one or more mappings; merely changing the value * associated with a key that an instance already contains is not a * structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the map. * 记住，实现类是非同步的。如果多线程操作，并且只要有一个在修改结构，必须确保同步操作。（任何增删扩容都是结构修改， * 仅仅是改变一个已经存在的键的值不属于结构修改）这个通常通过一些 object 来辅助实现 map 的同步封装。 * * If no such object exists, the map should be "wrapped" using the * &#123;@link Collections#synchronizedMap Collections.synchronizedMap&#125; * method. This is best done at creation time, to prevent accidental * unsynchronized access to the map:&lt;pre&gt; * Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt; * 如果没有这个 object 可用，这个 map 应该用 &#123;@link Collections#synchronizedMap Collections.synchronizedMap&#125; 方法包装。 * 这个最好在创建的时候就搞定，才能防止非同步访问的发生。 * Map m = Collections.synchronizedMap(new HashMap(...)); * * &lt;p&gt;The iterators returned by all of this class's "collection view methods" * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after * the iterator is created, in any way except through the iterator's own * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a * &#123;@link ConcurrentModificationException&#125;. Thus, in the face of concurrent * modification, the iterator fails quickly and cleanly, rather than risking * arbitrary, non-deterministic behavior at an undetermined time in the * future. * 这个迭代器返回了所有的这个类的“视图方法集合”就是 fail-fast：如果在迭代器创建后， * 除了调用迭代器自己的 remove 方法，在任意时刻被修改结构，将会跑出一个 &#123;@link ConcurrentModificationException&#125; * 因此，对于当前修改，在以后的不确定时间的不确定行为，迭代器会迅速清晰的 fails，而不是产生随机的风险。 * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * 记住，一个迭代器的 fail-fast 不能保证正常，通俗讲，不能在任何非同步的并发修改场合做担保。 * 迭代器的 fail-fast 力所能及的抛出 ConcurrentModificationException。因此，通过这个异常判断 * 可能在程序上有错误的编码：迭代器的 fail-fast 应当用于探测 bug * * &lt;p&gt;This class is a member of the * &lt;a href="&#123;@docRoot&#125;/../technotes/guides/collections/index.html"&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;K&gt; the type of keys maintained by this map * @param &lt;V&gt; the type of mapped values * * @author Doug Lea * @author Josh Bloch * @author Arthur van Hoff * @author Neal Gafter * @see Object#hashCode() * @see Collection * @see Map * @see TreeMap * @see Hashtable * @since 1.2 */public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 持久化版本ID，用于 Serializable 的序列化。 private static final long serialVersionUID = 362498820763181265L; /* * Implementation notes. * 实现笔记 * * This map usually acts as a binned (bucketed) hash table, but * when bins get too large, they are transformed into bins of * TreeNodes, each structured similarly to those in * java.util.TreeMap. Most methods try to use normal bins, but * relay to TreeNode methods when applicable (simply by checking * instanceof a node). Bins of TreeNodes may be traversed and * used like any others, but additionally support faster lookup * when overpopulated. However, since the vast majority of bins in * normal use are not overpopulated, checking for existence of * tree bins may be delayed in the course of table methods. * * Tree bins (i.e., bins whose elements are all TreeNodes) are * ordered primarily by hashCode, but in the case of ties, if two * elements are of the same "class C implements Comparable&lt;C&gt;", * type then their compareTo method is used for ordering. (We * conservatively check generic types via reflection to validate * this -- see method comparableClassFor). The added complexity * of tree bins is worthwhile in providing worst-case O(log n) * operations when keys either have distinct hashes or are * orderable, Thus, performance degrades gracefully under * accidental or malicious usages in which hashCode() methods * return values that are poorly distributed, as well as those in * which many keys share a hashCode, so long as they are also * Comparable. (If neither of these apply, we may waste about a * factor of two in time and space compared to taking no * precautions. But the only known cases stem from poor user * programming practices that are already so slow that this makes * little difference.) * * Because TreeNodes are about twice the size of regular nodes, we * use them only when bins contain enough nodes to warrant use * (see TREEIFY_THRESHOLD). And when they become too small (due to * removal or resizing) they are converted back to plain bins. In * usages with well-distributed user hashCodes, tree bins are * rarely used. Ideally, under random hashCodes, the frequency of * nodes in bins follows a Poisson distribution * (http://en.wikipedia.org/wiki/Poisson_distribution) with a * parameter of about 0.5 on average for the default resizing * threshold of 0.75, although with a large variance because of * resizing granularity. Ignoring variance, the expected * occurrences of list size k are (exp(-0.5) * pow(0.5, k) / * factorial(k)). The first values are: * * 0: 0.60653066 * 1: 0.30326533 * 2: 0.07581633 * 3: 0.01263606 * 4: 0.00157952 * 5: 0.00015795 * 6: 0.00001316 * 7: 0.00000094 * 8: 0.00000006 * more: less than 1 in ten million * * The root of a tree bin is normally its first node. However, * sometimes (currently only upon Iterator.remove), the root might * be elsewhere, but can be recovered following parent links * (method TreeNode.root()). * * All applicable internal methods accept a hash code as an * argument (as normally supplied from a public method), allowing * them to call each other without recomputing user hashCodes. * Most internal methods also accept a "tab" argument, that is * normally the current table, but may be a new or old one when * resizing or converting. * * When bin lists are treeified, split, or untreeified, we keep * them in the same relative access/traversal order (i.e., field * Node.next) to better preserve locality, and to slightly * simplify handling of splits and traversals that invoke * iterator.remove. When using comparators on insertion, to keep a * total ordering (or as close as is required here) across * rebalancings, we compare classes and identityHashCodes as * tie-breakers. * * The use and transitions among plain vs tree modes is * complicated by the existence of subclass LinkedHashMap. See * below for hook methods defined to be invoked upon insertion, * removal and access that allow LinkedHashMap internals to * otherwise remain independent of these mechanics. (This also * requires that a map instance be passed to some utility methods * that may create new nodes.) * * The concurrent-programming-like SSA-based coding style helps * avoid aliasing errors amid all of the twisty pointer operations. */ /** * The default initial capacity - MUST be a power of two. * 初始容量 —— 必须是 2 的幂 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka（有名） 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * 最大容量，如果构造时候被指定更大的容量，这个就会被隐式指定为其容量。 * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. * 默认加载因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * 链改成树的阀值 */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 树变成链的阀值 */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * 可能树化的最小容量 * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; /* ---------------- Static utilities -------------- */ /** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; /** * Returns x's Class if it is of the form "class C implements * Comparable&lt;C&gt;", else null. */ static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; /** * Returns k.compareTo(x) if x matches kc (k's screened comparable * class), else 0. */ @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; /* ---------------- Fields -------------- */ /** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; /** * The number of key-value mappings contained in this map. */ transient int size; /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount; /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; /* ---------------- Public operations -------------- */ /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; /** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; /** * Returns the number of key-value mappings in this map. * * @return the number of key-value mappings in this map */ public int size() &#123; return size; &#125; /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings. * * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings */ public boolean isEmpty() &#123; return size == 0; &#125; /** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the * specified key. * * @param key The key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. */ public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; /** * Copies all of the mappings from the specified map to this map. * These mappings will replace any mappings that this map had for * any of the keys currently in the specified map. * * @param m mappings to be stored in this map * @throws NullPointerException if the specified map is null */ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; /** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * Implements Map.remove and related methods * * @param hash hash for key * @param key the key * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; /** * Removes all of the mappings from this map. * The map will be empty after this call returns. */ public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value */ public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; /** * Returns a &#123;@link Set&#125; view of the keys contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of * the iteration are undefined. The set supports element removal, * which removes the corresponding mapping from the map, via the * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; * operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; * operations. * * @return a set view of the keys contained in this map */ public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a &#123;@link Collection&#125; view of the values contained in this map. * The collection is backed by the map, so changes to the map are * reflected in the collection, and vice-versa. If the map is * modified while an iteration over the collection is in progress * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), * the results of the iteration are undefined. The collection * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a view of the values contained in this map */ public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a &#123;@link Set&#125; view of the mappings contained in this map. * The set is backed by the map, so changes to the map are * reflected in the set, and vice-versa. If the map is modified * while an iteration over the set is in progress (except through * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the * iterator) the results of the iteration are undefined. The set * supports element removal, which removes the corresponding * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations. * * @return a set view of the mappings contained in this map */ public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; /* ------------------------------------------------------------ */ // Cloning and serialization /** * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and * values themselves are not cloned. * * @return a shallow copy of this map */ @SuppressWarnings("unchecked") @Override public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; /** * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e., * serialize it). * * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the * bucket array) is emitted (int), followed by the * &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value * mappings), followed by the key (Object) and value (Object) * for each key-value mapping. The key-value mappings are * emitted in no particular order. */ private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; /** * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e., * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException("Illegal load factor: " + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException("Illegal mappings count: " + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. // jdk1.8.0_91版本的还没有这行代码 SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings("unchecked") K key = (K) s.readObject(); @SuppressWarnings("unchecked") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // iterators abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; /* ------------------------------------------------------------ */ // spliterators static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; /* ------------------------------------------------------------ */ // LinkedHashMap support /* * The following package-protected methods are designed to be * overridden by LinkedHashMap, but not by any other subclass. * Nearly all other internal methods are also package-protected * but are declared final, so can be used by LinkedHashMap, view * classes, and HashSet. */ // Create a regular (non-tree) node Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; /** * Reset to initial default state. Called by clone and readObject. */ void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Tree bins /** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn * extends Node) so can be used as extension of either regular or * linked node. */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; /** * Ensures that the given root is the first node of its bin. */ static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; /** * Calls find for root node. */ final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; /** * Tie-breaking utility for ordering insertions when equal * hashCodes and non-comparable. We don't require a total * order, just a consistent insertion rule to maintain * equivalence across rebalancings. Tie-breaking further than * necessary simplifies testing a bit. */ static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; /** * Forms tree of the nodes linked from this node. * @return root of tree */ final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; /** * Returns a list of non-TreeNodes replacing those linked from * this node. */ final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; /** * Tree version of putVal. */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; /** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by "next" pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */ final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; /** * Splits nodes in a tree bin into lower and upper tree bins, * or untreeifies if now too small. Called only from resize; * see above discussion about split bits and indices. * * @param map the map * @param tab the table for recording bin heads * @param index the index of the table being split * @param bit the bit of hash to split on */ final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; /** * Recursive invariant check */ static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>源码翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【*】 - README]]></title>
    <url>%2Fsrc%2FREADME%2F</url>
    <content type="text"><![CDATA[123456src├─com.sun(SUN 公司扩展）├─java(Java SE 标准)├─javax(Java SE 标准扩展)├─launcher(JRE 启动入口)└─org(SUN 外的其他企业或者组织扩展) java.*java SE 的标准库，是 java 标准的一部分，是对外承诺的 java 开发接口，通常要保持向后兼容，一般不会轻易修改。包括其他厂家的在内，所有 jdk 的实现，在 java.* 上都是一样的。 javax.*也是 java 标准的一部分，但是没有包含在标准库中，一般属于标准库的扩展。通常属于某个特定领域，不是一般性的 api。 所以以扩展的方式提供 api，以避免 jdk 的标准库过大。当然某些早期的 javax，后来被并入到标准库中，所有也应该属于新版本 JDK 的标准库。比如 jmx，java 5 以前是以扩展方式提供，但是 jdk5 以后就做为标准库的一部分了，所有 javax.management 也是 jdk5 的标准库的一部分。 com.sun.*sun 的 hotspot 虚拟机中 java. 和 javax. 的实现类。因为包含在 rt.jar 中，所以我们也可以调用。但是因为不是 sun 对外公开承诺的接口，所以根据根据实现的需要随时增减，因此在不同版本的 hotspot 中可能是不同的，而且在其他的 jdk 实现中是没有的，调用这些类，可能不会向后兼容，所以一般不推荐使用。 org.*.*由企业或者组织提供的 java 类库，大部分不是 sun 公司提供的，同 com.sun.*，不具备向后兼容性，会根据需要随时增减。其中比较常用的是 w3c 提供的对 XML、网页、服务器的类和接口。 launcherJRE 中用于启动程序入口 main() 的类 引用：https://blog.csdn.net/m0_37499059/article/details/79271593]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【java.*】 - README]]></title>
    <url>%2Fjava%2FREADME%2F</url>
    <content type="text"><![CDATA[12345678910111213141516src └─java ├─applet(网页小应用程序应用包，已废弃） ├─awt(抽象窗口工具包) ├─beans(java bean 操作相关的包) ├─io(IO 操作的包) ├─lang(Java语言包，java 开发的基础类和一些基本的方法) ├─math(学及科学计算相关的包) ├─net(网络通讯包) ├─nio(New IO 操作包) ├─rmi(远程方法调用) ├─security(安全框架) ├─sql(数据库 API 包) ├─text(文本处理包) ├─time(日期时间包) └─util(常用工具包) java.applet包创建 java applet 小应用程序的主要包，可以嵌入到网页中能够呈现出特殊的效果，现在基本已经被废弃，很少使用。 java.awt包AWT 是 Abstract Window ToolKit (抽象窗口工具包)的缩写，这个工具包提供了一套与本地图形界面进行交互的接口。AWT 中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，当我们利用 AWT 来构件图形用户界面的时候，实际上是在利用操作系统所提供的图形库。AWT 所提供的图形功能是各种通用型操作系统所提供的图形功能的交集。 java.beans包java bean 操作相关的包 java.io包java 中 io 操作的包，通过数据流、序列化和文件系统提供系统输入和输出。 java.lang包java.lang 包包含了 java 开发的基础类和一些基本的方法。其中最重要的类就是 java.lang.Object类，它的对象是 Java 平台中所有其他类对象扩展层次树的根 java.math包一些数学及科学计算相关的包，提供用于执行任意精度整数算法 (BigInteger) 和任意精度小数算法 (BigDecimal) 的类。 java.net包java 网络通讯，如 socket 等操作 java.nio包nio是java New IO的简称，在jdk1.4里提供的新api。Sun官方标榜的特性如下： 为所有的原始类型提供(Buffer)缓存支持。 字符集编码解码解决方案。 Channel：一个新的原始 I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-bloking)非阻塞式的高伸缩性网络 I/O。 java.rmi包Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 java 编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。 java.security包java.security 包为安全框架提供类和接口。通过该包中的 Java 实现，仅仅能够完成消息摘要算法的实现（消息摘要处理的MessageDigest、DigestInputStream和DigestOutputStream类），并且其源代码是可见的。 java.sql包提供使用 JavaTM 编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。此 API 包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。 java.text包提供类和接口处理文本、日期、数字和消息的方式独立的自然语言。 java.time日期、时间相关包。 java.util包java 的常用工具类，包含 collection 框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 引用：https://blog.csdn.net/wuyong686/article/details/8178349]]></content>
      <tags>
        <tag>包结构</tag>
      </tags>
  </entry>
</search>
